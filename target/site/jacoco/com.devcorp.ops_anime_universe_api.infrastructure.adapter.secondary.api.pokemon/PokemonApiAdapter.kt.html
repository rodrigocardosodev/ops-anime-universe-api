<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PokemonApiAdapter.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ops-anime-universe-api</a> &gt; <a href="index.source.html" class="el_package">com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon</a> &gt; <span class="el_source">PokemonApiAdapter.kt</span></div><h1>PokemonApiAdapter.kt</h1><pre class="source lang-java linenums">package com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon

import com.devcorp.ops_anime_universe_api.domain.port.spi.PokemonApiClient
import com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon.dto.NamedApiResource
import com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon.dto.PokemonDetailResponse
import com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon.dto.PokemonPageResponse
import com.devcorp.ops_anime_universe_api.infrastructure.adapter.secondary.api.pokemon.dto.PokemonSprites
import com.devcorp.ops_anime_universe_api.infrastructure.config.WebClientConfig
import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker
import io.github.resilience4j.retry.annotation.Retry
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.cache.annotation.Cacheable
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.client.WebClient
import org.springframework.web.reactive.function.client.WebClientResponseException
import org.springframework.web.reactive.function.client.awaitBodilessEntity
import org.springframework.web.reactive.function.client.awaitBody

/** Adaptador para a PokeAPI */
<span class="fc" id="L22">@Component</span>
<span class="fc" id="L23">class PokemonApiAdapter(</span>
<span class="fc" id="L24">        private val webClientConfig: WebClientConfig,</span>
<span class="fc" id="L25">        @Value(&quot;\${external.api.pokemon.base-url}&quot;) private val baseUrl: String</span>
) : PokemonApiClient {

<span class="fc" id="L28">    private val logger = LoggerFactory.getLogger(PokemonApiAdapter::class.java)</span>

    // Criamos um WebClient específico para o Pokemon.
    // Não usamos o lazy aqui para evitar problemas de inicialização
<span class="fc" id="L32">    private val pokemonWebClient: WebClient = run {</span>
<span class="fc" id="L33">        val url = baseUrl.trim().removeSuffix(&quot;/&quot;)</span>
<span class="fc" id="L34">        logger.debug(&quot;Inicializando WebClient para PokeAPI com URL base: {}&quot;, url)</span>
<span class="fc" id="L35">        webClientConfig.webClientBuilder().baseUrl(url).build()</span>
    }

    @CircuitBreaker(name = &quot;pokemonApi&quot;, fallbackMethod = &quot;getPokemonsFallback&quot;)
    @Retry(name = &quot;pokemonApi&quot;)
    @Cacheable(value = [&quot;pokemon&quot;], key = &quot;'list-' + #offset + '-' + #limit&quot;)
<span class="nc" id="L41">    override suspend fun getPokemons(offset: Int, limit: Int): PokemonPageResponse {</span>
        // Para garantir que estamos buscando os primeiros Pokémon da primeira página
        // O offset da PokeAPI começa com 0 para o primeiro Pokémon (Bulbasaur)
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">        val adjustedOffset = if (offset == 0) 0 else offset * limit</span>
<span class="fc" id="L45">        val validLimit = limit.coerceAtLeast(1)</span>

<span class="fc" id="L47">        logger.info(</span>
<span class="fc" id="L48">                &quot;Buscando pokemons: offset ajustado $adjustedOffset (página original $offset), limite $validLimit&quot;</span>
        )
<span class="fc" id="L50">        logger.debug(</span>
<span class="fc" id="L51">                &quot;URL Base: {}, Endpoint: /pokemon?offset={}&amp;limit={}&quot;,</span>
<span class="fc" id="L52">                baseUrl,</span>
<span class="fc" id="L53">                adjustedOffset,</span>
<span class="fc" id="L54">                validLimit</span>
        )

<span class="fc" id="L57">        return try {</span>
<span class="fc" id="L58">            pokemonWebClient</span>
<span class="fc" id="L59">                    .get()</span>
<span class="fc" id="L60">                    .uri { uriBuilder -&gt;</span>
<span class="fc" id="L61">                        uriBuilder</span>
<span class="fc" id="L62">                                .path(&quot;/pokemon&quot;)</span>
<span class="fc" id="L63">                                .queryParam(&quot;offset&quot;, adjustedOffset)</span>
<span class="fc" id="L64">                                .queryParam(&quot;limit&quot;, validLimit)</span>
<span class="fc" id="L65">                                .build()</span>
                    }
<span class="fc" id="L67">                    .retrieve()</span>
<span class="fc" id="L68">                    .awaitBody&lt;PokemonPageResponse&gt;()</span>
<span class="fc" id="L69">        } catch (e: WebClientResponseException) {</span>
<span class="fc" id="L70">            logger.error(&quot;Erro HTTP ${e.statusCode} ao buscar lista de pokemons: ${e.message}&quot;, e)</span>
<span class="fc" id="L71">            createEmptyPageResponse()</span>
<span class="fc" id="L72">        } catch (e: Exception) {</span>
<span class="fc" id="L73">            logger.error(&quot;Erro ao buscar lista de pokemons: ${e.message}&quot;, e)</span>
<span class="fc" id="L74">            createEmptyPageResponse()</span>
        }
    }

    @CircuitBreaker(name = &quot;pokemonApi&quot;, fallbackMethod = &quot;getPokemonByNameFallback&quot;)
    @Retry(name = &quot;pokemonApi&quot;)
    @Cacheable(value = [&quot;pokemon&quot;], key = &quot;'detail-' + #name&quot;)
<span class="nc" id="L81">    override suspend fun getPokemonByName(name: String): PokemonDetailResponse {</span>
<span class="fc" id="L82">        logger.info(&quot;Buscando detalhes do pokemon: $name&quot;)</span>
<span class="fc" id="L83">        logger.debug(&quot;URL Base: {}, Endpoint: /pokemon/{}&quot;, baseUrl, name)</span>

<span class="fc" id="L85">        return try {</span>
<span class="fc" id="L86">            pokemonWebClient</span>
<span class="fc" id="L87">                    .get()</span>
<span class="fc" id="L88">                    .uri(&quot;/pokemon/{name}&quot;, name)</span>
<span class="fc" id="L89">                    .retrieve()</span>
<span class="fc" id="L90">                    .awaitBody&lt;PokemonDetailResponse&gt;()</span>
<span class="fc" id="L91">        } catch (e: WebClientResponseException) {</span>
<span class="fc" id="L92">            logger.error(</span>
<span class="fc" id="L93">                    &quot;Erro HTTP ${e.statusCode} ao buscar detalhes do pokemon $name: ${e.message}&quot;,</span>
<span class="fc" id="L94">                    e</span>
            )
<span class="fc" id="L96">            createEmptyDetailResponse(name)</span>
<span class="fc" id="L97">        } catch (e: Exception) {</span>
<span class="fc" id="L98">            logger.error(&quot;Erro ao buscar detalhes do pokemon $name: ${e.message}&quot;, e)</span>
<span class="fc" id="L99">            createEmptyDetailResponse(name)</span>
        }
    }

    @CircuitBreaker(name = &quot;pokemonApi&quot;, fallbackMethod = &quot;isAvailableFallback&quot;)
    @Retry(name = &quot;pokemonApi&quot;)
<span class="fc" id="L105">    override suspend fun isAvailable(): Boolean {</span>
<span class="fc" id="L106">        logger.info(&quot;Verificando disponibilidade da PokeAPI&quot;)</span>
<span class="fc" id="L107">        logger.debug(&quot;URL Base: {}, Endpoint: /pokemon?limit=1&quot;, baseUrl)</span>

<span class="fc" id="L109">        return try {</span>
<span class="fc" id="L110">            val response =</span>
<span class="fc" id="L111">                    pokemonWebClient.get().uri(&quot;/pokemon?limit=1&quot;).retrieve().awaitBodilessEntity()</span>
<span class="fc" id="L112">            logger.info(&quot;Status code da PokeAPI: {}&quot;, response.statusCode)</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            response.statusCode == HttpStatus.OK</span>
<span class="fc" id="L114">        } catch (e: Exception) {</span>
<span class="fc" id="L115">            logger.error(&quot;Erro ao verificar disponibilidade da PokeAPI: {}&quot;, e.message)</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            false</span>
        }
    }

    // Métodos de fallback
    suspend fun getPokemonsFallback(offset: Int, limit: Int, e: Exception): PokemonPageResponse {
<span class="fc" id="L122">        logger.warn(</span>
<span class="fc" id="L123">                &quot;Fallback acionado para getPokemons com offset $offset e limite $limit: ${e.message}&quot;,</span>
<span class="fc" id="L124">                e</span>
        )
<span class="fc" id="L126">        return createEmptyPageResponse()</span>
    }

    suspend fun getPokemonByNameFallback(name: String, e: Exception): PokemonDetailResponse {
<span class="fc" id="L130">        logger.warn(&quot;Fallback acionado para getPokemonByName com nome $name: ${e.message}&quot;, e)</span>
<span class="fc" id="L131">        return createEmptyDetailResponse(name)</span>
    }

    suspend fun isAvailableFallback(e: Exception): Boolean {
<span class="fc" id="L135">        logger.warn(&quot;Fallback acionado para isAvailable: ${e.message}&quot;, e)</span>
<span class="fc" id="L136">        return false</span>
    }

    // Métodos auxiliares para criar respostas vazias
    private fun createEmptyPageResponse(): PokemonPageResponse {
<span class="fc" id="L141">        return PokemonPageResponse(count = 0, next = null, previous = null, results = emptyList())</span>
    }

    private fun createEmptyDetailResponse(name: String): PokemonDetailResponse {
<span class="fc" id="L145">        return PokemonDetailResponse(</span>
<span class="fc" id="L146">                id = 0,</span>
<span class="fc" id="L147">                name = name,</span>
<span class="fc" id="L148">                height = 0,</span>
<span class="fc" id="L149">                weight = 0,</span>
                sprites =
<span class="fc" id="L151">                        PokemonSprites(</span>
<span class="fc" id="L152">                                front_default = null,</span>
<span class="fc" id="L153">                                front_shiny = null,</span>
<span class="fc" id="L154">                                back_default = null,</span>
<span class="fc" id="L155">                                back_shiny = null</span>
                        ),
<span class="fc" id="L157">                types = emptyList(),</span>
<span class="fc" id="L158">                species = NamedApiResource(name = &quot;&quot;, url = &quot;&quot;),</span>
<span class="fc" id="L159">                abilities = emptyList()</span>
        )
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>